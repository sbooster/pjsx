{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/*\n *  Copyright (C) 2025 CKATEPTb\n *\n * This file is part of pjsx-boilerplate.\n *\n * pjsx-boilerplate is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * pjsx-boilerplate is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program. If not, see <https://www.gnu.org/licenses/>.\n */\n\n\nimport * as preactRuntime from 'preact/jsx-runtime'\nimport {useEffect} from 'preact/hooks';\nimport {Flux, peek} from \"@pjsx/core\";\nimport {signal} from \"@preact/signals\";\n\nfunction isPublisher(props: any) {\n    return typeof props == 'object' && typeof props?.subscribe == 'function'\n}\n\nfunction jsx(tag: any, props: any, key?: string) {\n    const unwrap = (props: any): any => {\n        if (props == null) return props\n        if (Array.isArray(props)) return props.map(props => unwrap(props))\n        if (isPublisher(props)) return peek(signal<any>()).peek(signal => {\n            useEffect(() => {\n                const sub = Flux.from<any>(props)\n                    .distinctUntilChanged()\n                    .subscribe({\n                        onNext(value) {\n                            signal.value = value\n                        },\n                        onError(error) {\n                            console.error(error)\n                        }\n                    })\n                sub.request(Number.MAX_SAFE_INTEGER)\n                return () => {\n                    sub.unsubscribe()\n                }\n            }, [tag]);\n        }).get();\n        if (typeof props == \"object\") {\n            for (let key of Object.keys(props)) {\n                if (key == 'props' || key.startsWith('_')) continue\n                if (props[key] == null) continue\n                props[key] = unwrap(props[key])\n            }\n            return props\n        }\n        return props\n    }\n    return preactRuntime.jsx(tag, unwrap(props), key);\n}\n\nconst Fragment = preactRuntime.Fragment\nexport {jsx, jsx as jsxs, jsx as jsxDEV, Fragment}\n\nexport type {\n    JSXInternal as JSX\n} from '@/jsx'"],"mappings":";AAoBA,YAAY,mBAAmB;AAC/B,SAAQ,iBAAgB;AACxB,SAAQ,MAAM,YAAW;AACzB,SAAQ,cAAa;AAErB,SAAS,YAAY,OAAY;AAC7B,SAAO,OAAO,SAAS,YAAY,OAAO,OAAO,aAAa;AAClE;AAEA,SAASA,KAAI,KAAU,OAAY,KAAc;AAC7C,QAAM,SAAS,CAACC,WAAoB;AAChC,QAAIA,UAAS,KAAM,QAAOA;AAC1B,QAAI,MAAM,QAAQA,MAAK,EAAG,QAAOA,OAAM,IAAI,CAAAA,WAAS,OAAOA,MAAK,CAAC;AACjE,QAAI,YAAYA,MAAK,EAAG,QAAO,KAAK,OAAY,CAAC,EAAE,KAAK,CAAAC,YAAU;AAC9D,gBAAU,MAAM;AACZ,cAAM,MAAM,KAAK,KAAUD,MAAK,EAC3B,qBAAqB,EACrB,UAAU;AAAA,UACP,OAAO,OAAO;AACV,YAAAC,QAAO,QAAQ;AAAA,UACnB;AAAA,UACA,QAAQ,OAAO;AACX,oBAAQ,MAAM,KAAK;AAAA,UACvB;AAAA,QACJ,CAAC;AACL,YAAI,QAAQ,OAAO,gBAAgB;AACnC,eAAO,MAAM;AACT,cAAI,YAAY;AAAA,QACpB;AAAA,MACJ,GAAG,CAAC,GAAG,CAAC;AAAA,IACZ,CAAC,EAAE,IAAI;AACP,QAAI,OAAOD,UAAS,UAAU;AAC1B,eAASE,QAAO,OAAO,KAAKF,MAAK,GAAG;AAChC,YAAIE,QAAO,WAAWA,KAAI,WAAW,GAAG,EAAG;AAC3C,YAAIF,OAAME,IAAG,KAAK,KAAM;AACxB,QAAAF,OAAME,IAAG,IAAI,OAAOF,OAAME,IAAG,CAAC;AAAA,MAClC;AACA,aAAOF;AAAA,IACX;AACA,WAAOA;AAAA,EACX;AACA,SAAqB,kBAAI,KAAK,OAAO,KAAK,GAAG,GAAG;AACpD;AAEA,IAAMG,YAAyB;","names":["jsx","props","signal","key","Fragment"]}